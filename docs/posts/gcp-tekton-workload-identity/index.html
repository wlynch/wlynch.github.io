<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.59.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Tekton and GKE Workload Identity &middot; Billy Lynch</title><meta name=description content><link type=text/css rel=stylesheet href=https://wlyn.ch/css/print.css media=print><link type=text/css rel=stylesheet href=https://wlyn.ch/css/poole.css><link type=text/css rel=stylesheet href=https://wlyn.ch/css/syntax.css><link type=text/css rel=stylesheet href=https://wlyn.ch/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://wlyn.ch/><h1>Billy Lynch</h1></a><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://wlyn.ch/>Home</a></li><li><a href=https://github.com/wlynch>GitHub</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Tekton and GKE Workload Identity</h1><time datetime=2021-03-04T00:00:00Z class=post-date>Thu, Mar 4, 2021</time><h1 id=what-is-workload-identity>What is Workload Identity?</h1><p>When running a workload on Kubernetes, each Pod has an underlying <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/>service account</a> identity that is used for interacting with the Kubernetes API and resources.</p><p>GCP has a similar concept of <a href=https://cloud.google.com/iam/docs/service-accounts>service accounts</a> as a means for programs to authenticate to Google APIs. To make management of these secrets easier, GCP compute environments provide a mechanism called <a href=https://cloud.google.com/docs/authentication/production#automatically>Application Default Credentials</a> that allows users to map a VM to a particular service account. When this is done, GCP libraries running on that VM can fetch credentials for the configured service account automatically by using the VM&rsquo;s baked in <a href=https://cloud.google.com/compute/docs/storing-retrieving-metadata>Metadata Service</a>.</p><p>Although they share the same name, Kubernetes Service Accounts (KSA) are separate from Google Service Accounts (GSA). By default when you run a workload on Kubernetes, Application Default Credentials will use the service account associated to the Node (i.e. VM) regardless of the Pod&rsquo;s KSA.
If you wanted to ensure that different Pods used different GSA identities, you would either need to pass in service account credentials manually or separate workloads onto different Nodes (which means you need to peel back Kubernetes abstractions to be aware of the underlying node pools you are running on).</p><p>Both of these options aren&rsquo;t great - ideally we would be able to use KSAs just like GSAs to scope GCP permissions for each running Pod. This is where <a href=https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity>GKE Workload Identity</a> comes in! Workload Identity allows you to map KSAs to corresponding GSAs so that Application Default Credentials in Pods can fetch GSA credentials based on the Pod&rsquo;s KSA identity.</p><p>This is a great feature that allows you to authenticate to external GCP services, without needing to worry about managing credentials. With Tekton this is particularly useful since we often need to interact with GCP resources as part of CI/CD:</p><ul><li>Push/Pull from Artifact Registry</li><li>Read/Write from GCS</li><li>Git clone from Cloud Source Repositories</li><li>Deploy to Cloud Run / App Engine / GCE / GKE / etc.</li></ul><h1 id=configuring-tekton>Configuring Tekton</h1><p>Since Tekton runs on Kubernetes, we can use Workload Identity to simplify credential management when running on GKE.</p><p>If you don&rsquo;t have Workload Identity enabled on your cluster yet, check out <a href=https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity#enable_on_cluster>this guide</a> to get set up.
The following examples assume that the Workload Identity feature is already enabled on your cluster.</p><h2 id=authentication-in-a-task>Authentication in a Task</h2><p>For this example, we will set up a simple Tekton build, using Workload Identity to handle pushing the artifact.</p><p>We will create a KSA named <code>build-robot</code> with a GSA with the same name e.g. <code>build-robot@${PROJECT_ID}.iam.gserviceaccount.com</code>.</p><p>For this example I am using <code>wlynch-test</code> as my GCP project - replace this with your own!</p><ol><li><p>Create the KSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl create serviceaccount build-robot</code></pre></div></li><li><p>Create the GSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>gcloud iam service-accounts create build-robot</code></pre></div></li><li><p>Grant the GSA permissions to push to the image repository</p><p>For our example, we will use <code>us-docker.pkg.dev/wlynch-test/test</code>.</p><p>If you&rsquo;re unfamiliar with the <code>pkg.dev</code> URL - this is an <a href=https://cloud.google.com/artifact-registry>Artifact Registry</a> URL, the successor to GCR. Highly recommend trying it out if you haven&rsquo;t yet!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ gcloud artifacts repositories add-iam-policy-binding test <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--location us <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--member<span style=color:#f92672>=</span>serviceAccount:build-robot@wlynch-test.iam.gserviceaccount.com <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--role<span style=color:#f92672>=</span>roles/artifactregistry.writer</code></pre></div></li><li><p>Setup Workload Identity Mappings</p><ul><li><p>KSA -&gt; GSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl annotate serviceaccount <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>build-robot <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>iam.gke.io/gcp-service-account<span style=color:#f92672>=</span>build-robot@wlynch-test.iam.gserviceaccount.com</code></pre></div></li><li><p>GSA -&gt; KSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>gcloud iam service-accounts add-iam-policy-binding <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--role roles/iam.workloadIdentityUser <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--member <span style=color:#e6db74>&#34;serviceAccount:wlynch-test.svc.id.goog[default/build-robot]&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>build-robot@wlynch-test.iam.gserviceaccount.com</code></pre></div></li></ul></li><li><p>Build and Push</p><p>Given the following <code>taskrun.yaml</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: tekton.dev/v1beta1
kind: TaskRun
metadata:
  name: workload-identity
spec:
  serviceAccountName: build-robot
  taskSpec:
    steps:
      - name: checkout
        image: docker.io/alpine/git
        args: [<span style=color:#e6db74>&#34;clone&#34;</span>, <span style=color:#e6db74>&#34;https://github.com/googlecloudplatform/cloud-run-hello&#34;</span>, <span style=color:#e6db74>&#34;.&#34;</span>]
      <span style=color:#75715e># This step isn&#39;t necessary - it just prints out the</span>
      <span style=color:#75715e># current authenticated user.</span>
      - name: check-auth
        image: gcr.io/google.com/cloudsdktool/cloud-sdk
        args: [<span style=color:#e6db74>&#34;gcloud&#34;</span>, <span style=color:#e6db74>&#34;auth&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>]
      - name: build
        image: <span style=color:#e6db74>&#34;gcr.io/kaniko-project/executor:v1.5.1&#34;</span>
        args: [
          <span style=color:#e6db74>&#34;--dockerfile=Dockerfile&#34;</span>,
          <span style=color:#e6db74>&#34;--context=dir://.&#34;</span>,
          <span style=color:#e6db74>&#34;--destination=us-docker.pkg.dev/wlynch-test/test/cloud-run-hello:latest&#34;</span>,
        ]</code></pre></div><p>We can execute this by running:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl apply -f taskrun.yaml</code></pre></div><p>The <code>kaniko</code> step will automatically use Application Default Credentials + Workload Identity to get a credential for the configured GSA and push the image to the repository!</p></li></ol><h2 id=using-private-images>Using Private Images</h2><p>In the example above, we used publicly available builder images to push a private image. But what if we want to use a private image in a build step?</p><p>This is a bit more complicated, since there&rsquo;s actually multiple identities that need to read the image when Tasks are scheduled-</p><ol><li>The underlying TaskRun Pod needs to fetch the image to run it.</li><li>The Tekton Pipeline controller needs to read the image metadata to properly <a href=https://github.com/tektoncd/pipeline/blob/master/docs/container-contract.md>set up the Tekton runtime environment</a>.</li></ol><p>Both KSAs need to be configured with Workload Identity in order for Tekton to handle private images.</p><h3 id=grant-the-taskrun-pod-access>Grant the TaskRun Pod Access</h3><p>We already have Workload Identity set up from the last section, so we can reuse this and simply grant the GSA any additional read permissions it needs. For example, to grant read-only permissions to all Artifact Registry Docker repositories in the project:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ gcloud projects add-iam-policy-binding wlynch-test <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--member<span style=color:#f92672>=</span>serviceAccount:build-robot@wlynch-test.iam.gserviceaccount.com <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--role<span style=color:#f92672>=</span>roles/artifactregistry.reader</code></pre></div><h3 id=grant-the-tekton-controller-access>Grant the Tekton Controller Access</h3><p>To grant the Tekton controller access, we largely follow the same process as before, but use the controller&rsquo;s namespace (<a href=https://github.com/tektoncd/pipeline/blob/3ea59814fefa0650dede90a09e9a43af214480d6/config/controller.yaml#L19><code>tekton-pipelines</code></a>) and service account (<a href=https://github.com/tektoncd/pipeline/blob/3ea59814fefa0650dede90a09e9a43af214480d6/config/controller.yaml#L54><code>tekton-pipelines-controller</code></a>).</p><ol><li><p>Create the GSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>gcloud iam service-accounts create tekton-pipelines-controller</code></pre></div></li><li><p>Grant the GSA read permissions.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ gcloud projects add-iam-policy-binding wlynch-test <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--member<span style=color:#f92672>=</span>serviceAccount:tekton-pipelines-controller@wlynch-test.iam.gserviceaccount.com <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--role<span style=color:#f92672>=</span>roles/artifactregistry.reader</code></pre></div></li><li><p>Setup Workload Identity Mappings</p><ol><li><p>KSA -&gt; GSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl annotate serviceaccount <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-n tekton-pipelines <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>tekton-pipelines-controller <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>iam.gke.io/gcp-service-account<span style=color:#f92672>=</span>tekton-pipelines-controller@wlynch-test.iam.gserviceaccount.com</code></pre></div></li><li><p>GSA -&gt; KSA</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>gcloud iam service-accounts add-iam-policy-binding <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--role roles/iam.workloadIdentityUser <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>--member <span style=color:#e6db74>&#34;serviceAccount:wlynch-test.svc.id.goog[tekton-pipelines/tekton-pipelines-controller]&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>tekton-pipelines-controller@wlynch-test.iam.gserviceaccount.com</code></pre></div></li></ol></li><li><p>Build with a private image</p><p>To test this, we&rsquo;ll use a slightly modified taskrun.yaml, replacing the kaniko builder image with a copy hosted in our own repository.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: tekton.dev/v1beta1
kind: TaskRun
metadata:
  name: workload-identity
spec:
  serviceAccountName: build-robot
  taskSpec:
    steps:
      - name: checkout
        image: docker.io/alpine/git
        args: [<span style=color:#e6db74>&#34;clone&#34;</span>, <span style=color:#e6db74>&#34;https://github.com/googlecloudplatform/cloud-run-hello&#34;</span>, <span style=color:#e6db74>&#34;.&#34;</span>]
      - name: build
        <span style=color:#75715e># This is the same image as before but in a private repo.</span>
        image: <span style=color:#e6db74>&#34;us-docker.pkg.dev/wlynch-test/test/kaniko:v1.5.1&#34;</span>
        args: [
          <span style=color:#e6db74>&#34;--dockerfile=Dockerfile&#34;</span>,
          <span style=color:#e6db74>&#34;--context=dir://.&#34;</span>,
          <span style=color:#e6db74>&#34;--destination=us-docker.pkg.dev/wlynch-test/test/cloud-run-hello:latest&#34;</span>,
        ]</code></pre></div></li></ol><h1 id=related-docs>Related Docs</h1><p>Here are some links I found helpful to understand how Workload Identity works:</p><ul><li><a href="https://www.youtube.com/watch?v=s4NYEJDFc0M">Keyless Entry: Securely Access GCP Services From Kubernetes (Cloud Next &lsquo;19)</a> - Technical overview on how Workload Identity works</li><li><a href=https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity>https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity</a> - Step by step guide for setting up and configuring Workload Identity on your cluster.</li><li><a href=https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-autopilot>https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-autopilot</a> - Managed GKE clusters with Workload Identity enabled by default. 😎</li></ul></div></main><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51544701-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>